package model;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.HashMap;

import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonValue;

import org.apache.commons.codec.digest.DigestUtils;
import org.bouncycastle.util.encoders.Base64;

import controller.MiningVerifyController;
import database.DAO;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;
import model.PeerModel.Peer;

public class PeerThread extends Thread {

	private BufferedReader bufferedReader;
	private int port;
	private int localPort;
	private String localHostAddress = null;
	private String hostAddress = null;
	private Socket socket = null;
	private PeerModel peerModel;
	private Peer peer;
	PrintWriter printWriter;
	private DAO dao = null;
	
	

	public PeerThread(Socket socket, PeerModel peerModel) throws IOException{
		this.peerModel = peerModel;
		this.socket = socket;
		this.localHostAddress = socket.getLocalAddress().getHostName(); // 해당 Peer의 로컬 주소
		this.localPort = socket.getLocalPort(); // 해당 Peer의 포트
		this.port = socket.getPort(); // 연결된 서버의 포트
		this.hostAddress = socket.getInetAddress().getHostName(); // 연결된 서버의 주소
		this.bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 소켓의 inputStream을 bufferedReader 버퍼에 연결시키기
		this.printWriter = new PrintWriter(socket.getOutputStream(),true); // 상대 서버스레드로 보내는 PrintWriter
		this.dao = new DAO();
	}
	public void run() {
		boolean flag = true;
		while(flag) {
			try {
				HashMap<String,String> additems = new HashMap<String,String>();
				// 블록정보와 트랜잭션 정보를 이쪽에서 처리
				JsonObject jsonObject = Json.createReader(bufferedReader).readObject();
				///////////////////////////////blocking///////////////////////////////////
				// 다른 Peer에서 블록을 채굴을 완료한 경우 검증
				if(jsonObject.containsKey("nonce")) {
					// 정확한 검증을 위한 초기화
					peerModel.totalRespondedCount=0;
					peerModel.verifiedPeerCount =0;
					
					// 검증 시작
					String previousHash = peerModel.blockchainModel.getBlocks().get(peerModel.blockchainModel.getBlocks().size()-1).getHash();// 이전 해시
					String nonce = jsonObject.getString("nonce");
					String timestamp = jsonObject.getString("timestamp");
					
					int result = verifyBlock(previousHash,nonce,timestamp); // 검 증
						// 검증 성공 결과를 모든 Peer에게 보내기
						// ? 결과도 암호화하여 전송해보기 
					
					peerModel.totalRespondedCount += 1; // 본인 
					
					if(result == 1) { // 검증 성공
						additems.put("verified", "true");
						additems.put("blockNum", Block.count+"");
						peerModel.getServerListerner().sendMessage(peerModel.makeJsonObject(additems));
						peerModel.verifiedPeerCount += 1; // 본인
					}else { // 검증 실패
						additems.put("verified", "false");
						additems.put("blockNum", Block.count+"");
						peerModel.getServerListerner().sendMessage(peerModel.makeJsonObject(additems));
					}
					
					// 임시 블럭 미리 생성해놓기
					Block.count++; //블럭넘버 1 증가시키기
					peerModel.block = new Block(previousHash,nonce,timestamp,Block.count);
					System.out.println("검증 완료 Block 카운트 : "+Block.count);
					
					if(!peerModel.proofOfWorkCompleteFlag) peerModel.proofOfWorkCompleteFlag = true;	// 현재 채굴 중이라면
					else { // 현재 채굴중이 아니라면
						System.out.println("채굴 중이 아닌 경우 검증 시작");
						Thread verifyThread = new Thread() {
							public void run() {
									try {
										int result = peerModel.verifyBlock();
										if(result == 1) {
											Platform.runLater(()->{
												try {
													peerModel.proofOfWorkCompleteFlag = true;
													FXMLLoader loader = new FXMLLoader(getClass().getResource("/View/miningVerify.fxml"));
													Parent root = loader.load();
													Scene scene = new Scene(root);
													Stage stage = new Stage();
													stage.setScene(scene);
													stage.setX(peerModel.primaryStage.getX()+320);
													stage.setY(peerModel.primaryStage.getY());
													stage.show();
													
													MiningVerifyController mvc = loader.getController();
													mvc.resultOfVerify(peerModel.block);	
													
												} catch (IOException e) {e.printStackTrace();}
											});
										}else {
											Platform.runLater(()->{
												try {
													peerModel.proofOfWorkCompleteFlag = true;
													FXMLLoader loader = new FXMLLoader(getClass().getResource("/View/miningVerify.fxml"));
													Parent root = loader.load();
													Scene scene = new Scene(root);
													Stage stage = new Stage();
													stage.setScene(scene);
													stage.setX(peerModel.primaryStage.getX()+320);
													stage.setY(peerModel.primaryStage.getY());
													stage.show();
													
													MiningVerifyController mvc = loader.getController();
													mvc.failedVerify(peerModel.block);	
													
												} catch (IOException e) {e.printStackTrace();}
											});
										}		
									} catch (InterruptedException e) {e.printStackTrace();} 
							}
							
						};
						
						verifyThread.start();
						
					} 
				}
			
				
				//다른 Peer들의 검증 결과
				if(jsonObject.containsKey("verified")) {
						peerModel.totalRespondedCount++; // 다른 Peer 추가 
						if(jsonObject.getString("verified").equals("true")){ // 검증 성공이면 true
							System.out.println(hostAddress +":"+this.getPort()+ "의 검증여부 : true");
							peer.setBlockNum(Integer.parseInt(jsonObject.getString("blockNum"))); 
							peerModel.verifiedPeerCount++;
						}else { 
							System.out.println(hostAddress +":"+this.getPort() + "의 검증여부 : false"); 
							peer.setBlockNum(Integer.parseInt(jsonObject.getString("blockNum"))); 
							}		
				}
				//블록 요청 후 리더 Peer로부터 블럭 받기
				if(jsonObject.containsKey("requestVerified")) {
					boolean requestVerified = jsonObject.getBoolean("requestVerified");
					String previousHash = jsonObject.getString("RpreviousHash");
					String nonce = jsonObject.getString("Rnonce");
					String timestamp = jsonObject.getString("Rtimestamp");
					
					//검증이 완료되어 일부 블록만 받는 경우
					if(requestVerified) {
						Block.count++;
						peerModel.block = new Block(previousHash,nonce,timestamp,Block.count);
						peerModel.blockchainModel.getBlocks().add(new Block(previousHash,nonce,timestamp,Block.count));
						dao.storeBlock(peerModel.block,peerModel.walletModel.getUsername());
						
					}else { //검증이 실패하여 처음부터 받는 경우
						if(peerModel.isFirst) {
							Block.count = 0; 
							dao.deleteAllBlock(peerModel.walletModel.getUsername());
							peerModel.blockchainModel.resetBlocks().add(new Block(previousHash,nonce,timestamp,Block.count)); // 새로운 블록체인에 정리
							peerModel.isFirst = false; // 다음부터는 0이 아닌 연달아 받기
						}else {
							Block.count++;
							peerModel.block = new Block(previousHash,nonce,timestamp,Block.count);
							peerModel.blockchainModel.getBlocks().add(new Block(previousHash,nonce,timestamp,Block.count));
							dao.storeBlock(peerModel.block,peerModel.walletModel.getUsername());
						}
					}
				}
				//본인이 리더라고 알리는 Peer와 연결된 PeerThread를 PeerModel 변수에 저장
				if(jsonObject.containsKey("leader")) {
					if(jsonObject.getInt("leaderBlockNum") > Block.count) {
						peer.setLeader(true); 
						peerModel.amILeader = false;
					}else { // 만약 자신이 더 블럭 개수가 많은 경우
						peerModel.amILeader = true;
						additems.put("biggerThanYou", Block.count+"");
						additems.put("username", peer.getUserName());
						send(peerModel.makeJsonObject(additems));
					}
				}
				
				//거래 트랜잭션이 들어 온 경우
				if(jsonObject.containsKey("signature")) {
					
					//송금자 공개키 획득
					byte[] byteSender = Base64.decode(jsonObject.getString("sender"));
					X509EncodedKeySpec spec1 = new X509EncodedKeySpec(byteSender);
					KeyFactory factory1 = KeyFactory.getInstance("ECDSA","BC");
					PublicKey sender = factory1.generatePublic(spec1);
					//수금자 공개키 획득
					byte[] byteRecipient = Base64.decode(jsonObject.getString("recipient"));
					X509EncodedKeySpec spec2 = new X509EncodedKeySpec(byteRecipient);
					KeyFactory factory2 = KeyFactory.getInstance("ECDSA","BC");
					PublicKey recipient = factory2.generatePublic(spec2);
					
					//송금액 획득
					float value = Float.parseFloat(jsonObject.getString("value"));
					
					//전자서명 획득
					byte[] signature = Base64.decode(jsonObject.getString("signature"));
					String transactionHash = jsonObject.getString("transactionHash");
					//트랜잭션생성
					Transaction newTransaction = new Transaction(sender,recipient,value);
					newTransaction.setSignature(signature);
					newTransaction.setHash(transactionHash);
					
					for(int i=0; i< jsonObject.getJsonArray("miners").size();i++) {
						JsonValue miner = jsonObject.getJsonArray("miners").get(i);
						JsonValue utxoHash = jsonObject.getJsonArray("utxoHashs").get(i);
						System.out.println("트랜잭션 input miner : " + miner.toString());
						System.out.println("트랜잭션 input hash : " + utxoHash.toString());
						TransactionInput input = new TransactionInput(miner.toString(),utxoHash.toString());
						input.setTransactionHash(newTransaction.getHash());
						newTransaction.inputs.add(input);
					}
				
					//전자서명 검증에 성공하면 TransactionList에 임시저장
					if(newTransaction.verifySignature()) {
						peerModel.transactionList.add(newTransaction); // TransactioList는 합의에 성공하면 refresh되어야 함.
						System.out.println("트랜잭션 리스트에 추가");
						//next : minerController.java
					}
				}
				
				//UTXO 요청
				if(jsonObject.containsKey("requestUTXO")) {
					System.out.println("UTXO요청 잘 들어옴");
					byte[] byteOwner = Base64.decode(jsonObject.getString("owner"));
					X509EncodedKeySpec spec = new X509EncodedKeySpec(byteOwner);
					KeyFactory factory = KeyFactory.getInstance("ECDSA","BC");
					PublicKey owner = factory.generatePublic(spec);
					
					for(int i=0; i<peerModel.UTXOs.size();i++) {
						TransactionOutput UTXO = peerModel.UTXOs.get(i);
						if(UTXO.isMine(owner)) {
							additems.put("responseUTXO","");
							additems.put("nonce",UTXO.getNonce()+"");
							additems.put("miner", UTXO.getMiner());
							additems.put("utxoHash", UTXO.getTxoHash());
							additems.put("value", UTXO.value+"");
							send(peerModel.makeJsonObject(additems));
						}
					}
				}
				
				if(jsonObject.containsKey("sendUTXO")) {					
					//UTXO 검증
					String utxoHash = jsonObject.getString("sendUTXO");
					double nonce = Double.parseDouble(jsonObject.getString("nonce"));
					String miner = jsonObject.getString("miner");
					float value = Float.parseFloat(jsonObject.getString("value"));
					String txHash = jsonObject.getString("txHash");
					
					byte[] byteRecipient = Base64.decode(jsonObject.getString("recipient"));
					X509EncodedKeySpec spec = new X509EncodedKeySpec(byteRecipient);
					KeyFactory factory = KeyFactory.getInstance("ECDSA","BC");
					PublicKey recipient = factory.generatePublic(spec);
					
					//검증 성공
					if(utxoHash.equals(DigestUtils.sha256(miner+nonce+value+recipient))) {
						System.out.println("채굴 성공 측 : UTXO 검증 성공 및 수신 완료");
						TransactionOutput UTXO = new TransactionOutput(recipient,value,miner);
						UTXO.setHash(utxoHash);
						UTXO.setNonce(nonce);
						UTXO.setTransactionHash(txHash);
						
						for(Transaction tx : peerModel.transactionList) {
							if(tx.getHash().equals(UTXO.getTransactionHash())) {
								tx.outputs.add(UTXO);
							}
						}
						
						//UTXO 삭제 요청 보내기
						additems = new HashMap<String,String>();
						additems.put("deleteUTXO",utxoHash);
						send(peerModel.makeJsonObject(additems));
					}
				}
				//상대방의 연결이 끊겼을 경우 peerList에서 제거
			} catch (Exception e) {
				try {
					e.printStackTrace();
					for(Peer peer : peerModel.peerList) {
						if(peer.getPeerThread() == PeerThread.this) {
							peerModel.peerList.remove(peer);
							break;
						}
					}
					socket.close();
					flag=false;

				} catch (IOException e1) { e1.printStackTrace();}
			}
		}
	}
	
	//P2P 네트워크 망에 연결되어 있는 Peer둘에게 연결 요청 보내기
	public void addressSend(String localhost) throws IOException {
		HashMap<String,String> additems = new HashMap<String,String>();
		additems.put("localhost", localhost);
		additems.put("username",peerModel.walletModel.getUsername());
		send(peerModel.makeJsonObject(additems));
	}

	// 다른 Peer에서 채굴된 블럭 검증하기
	private int verifyBlock(String previousBlockHash, String nonce, String timestamp) throws NoSuchAlgorithmException{
		String hashString = DigestUtils.sha256Hex(previousBlockHash+nonce+timestamp); // 해당 데이터들을 SHA256으로 해싱
		// 정말  Pow_MAX_Bound보다 작은지 검증
		if(hashString.substring(0,peerModel.zeroNum).equals(peerModel.hashDifficulty)) return 1;
		else return -1;	
	}
	
	// 리더Peer에게 블럭 요청하기 
	public void requestBlock() {
			HashMap<String,String> additems = new HashMap<String,String>();
			additems.put("blockNum", Block.count+"");
			additems.put("blockHash",peerModel.blockchainModel.getBlocks().get(peerModel.blockchainModel.getBlocks().size()-1).getHash());
			send(peerModel.makeJsonObject(additems));
	}
	
	//리더 Peer에게 본인이 리더임을 알림, 리더는 블록개수가 많은 Peer가 리더가 된다. 그러므로 여러명의 리더가 나올 수 있음(블록개수가 같은 경우)
	public void sendLeader() {
		HashMap<String,String> additems = new HashMap<String,String>();
		additems.put("miningLeader", "true");
		send(peerModel.makeJsonObject(additems));
	}
	
	public void send(String sw) {
		printWriter.println(sw);
	}
	
	public Peer getPeer() {
		return peer;
	}
	public void setPeer(Peer peer) {
		this.peer = peer;
	}
	
	public int getPort() { return this.port;} // 연결된 서버 스레드 스레드의 포트 반환
	public String getHostAddress() { return this.hostAddress;} // 연결된 서버 스레드 스레드의 주소 반환
	public String toString() { return this.localHostAddress+":"+this.localPort;} // 본인의 주소:포트 반환
	
}
